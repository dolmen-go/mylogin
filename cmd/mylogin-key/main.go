// This program dumps the key of mylogin.cnf files
// (for exploring the key space)

package main

import (
	"bufio"
	"encoding/base64"
	"flag"
	"fmt"
	"log"
	"os"

	"github.com/dolmen-go/mylogin"
)

func printKey(key mylogin.Key) {
	// Files generated by mysql_config_editor do not use byte
	// values above 31 (just 5 significant bits). This is probably
	// to avoid printable characters.
	//
	// Let's validate our assumption...
	for _, b := range key {
		if b >= 32 {
			fmt.Printf("%X\n", key)
			return
		}
	}

	var compactKey [(len(key)*5 + 7) / 8]byte
	var j int
	var acc uint // accumultator
	var accBits uint
	for _, b := range key {
		acc = (acc << 5) | uint(b)
		accBits += 5
		for accBits >= 8 {
			accBits -= 8
			compactKey[j] = byte(acc >> accBits)
			j++
		}
	}
	// Only 4 bits remain
	compactKey[j] = byte(acc << (8 - accBits))

	//fmt.Printf("%X\n", key)

	// Encode to base64 but remove the last char
	b64 := base64.RawURLEncoding.EncodeToString(compactKey[:])[:(len(key)*5+5)/6]

	// Print only the high nibble of the last byte
	const hex = "0123456789ABCDEF"
	fmt.Printf("%X%c %s\n",
		compactKey[:len(compactKey)-1], hex[compactKey[len(compactKey)-1]>>4],
		b64)
}

func main() {
	flag.Parse()

	var filenames []string
	if len(os.Args) > 1 {
		filenames = os.Args[1:]
	} else {
		filenames = []string{mylogin.DefaultFile()}
	}

	for _, filename := range filenames {
		func(filename string) {
			f, err := os.Open(filename)
			if err != nil {
				log.Fatal(filename, ": ", err)
			}
			defer f.Close()

			file, err := mylogin.Decode(bufio.NewReader(f))
			if err != nil {
				log.Fatal(filename, ": ", err)
			}
			printKey(file.Key())
		}(filename)
	}
}
